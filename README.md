# Red-Black-Tree implemented with a Binary Search Tree
This is a project I did in my Data Structures and Algorithms Class.

#Description:

You will compare the performance of simple binary search trees versus red-black trees by reading in a corpus of text, storing the words therein into a search tree, and then performing manipulations on the resulting tree. You will implement the following functions for both kinds of trees: insert which inserts a value into the tree (or updates a frequency count) delete which decreases a frequency count (or removes a value from the tree) find which reports the frequency of a value in the tree These operations should maintain bst ordering. You will also implement an interpreter which processes requests to manipulate the trees. Your interpreter should handle the following commands:

    i W	insert word W into the tree
    d W	delete word W from the tree
    f W	report the frequency of word W
    s	show the tree
    r	report statistics
Legal tree values are simply words from the character set [a-z]. When reading a word, you should read a whitespace delimited token and then delete from it all non-letter characters. You should then convert all upper-case letters to lower case. For example, "Girl's." would be rendered as "girls". Do not insert empty strings into the tree.

Inserting a word already in the tree would increase its frequency count by one. When deleting a word from the tree, you should reduce its frequency count by one. If the frequency count goes to zero, you should remove its corresponding node completely from the tree.

When showing the tree, display the nodes with a breadth-first (left-first) traversal. All nodes at a given level should be on the same line of output. The level number should precede the display of the nodes at that level. Display each node according to the following format:

    an optional equals sign (if the node is a leaf), followed by
    the node value, followed by
    an optional asterisk (if the node is colored red), followed by
    a parenthesized display of the parent's value and color, followed by
    the frequency count, followed
    an X if the node is the root, an L if the node is a left child, and an R otherwise
Note that the parent of the root is itself. For the simple bst, all nodes are considered black. Here is an example of a red-black tree:

    1: beta(beta)1X
    2: =alpha*(beta)1L =gamma*(beta)1R
If the colors were reversed, the tree would display as:

    1: beta*(beta*)1X
    2: =alpha(beta*)1L =gamma(beta*)1R
The corpus to generate such a tree might look like:

    beta alpha
        gamma
The words should be ordered within a tree in case-insensitive lexicographic ordering. Suppose the corpus was:

    The quick brown fox
        jumped over the girl
             and her lazy, lazy dog.
found in a file named data. Suppose the file rbcommands holds the command:

    s
Then a display of a bst generated by this corpus would look something like:

    $ java -classpath classfiles main.Trees -1 data rbcommands
    1: the(the)2X
    2: quick(the)1L
    3: brown(quick)1L
    4: =and(brown)1L fox(brown)1R
    5: =dog(fox)1L jumped(fox)1R
    6: girl(jumped)1L over(jumped)1R
    7: =her(girl)1R =lazy(over)2L
When inserted into a red-black tree, the resulting structure might look like:

    $ java -classpath classfiles main.Trees -2 data rbcommands
    1: jumped(jumped)1X
    2: fox*(jumped)1L quick*(jumped)1R
    3: brown(fox*)1L girl(fox*)1R over(quick*)1L =the(quick*)2R
    4: =and*(brown)1L =dog*(brown)1R =her*(girl)1R =lazy*(over)2L
The statistics to be reported are:

    the number of nodes in the tree
    the minimum depth of the tree (the root is at depth 1)
    the maximum depth of the tree (the root is at depth 1)
The commands will be read from a free format file; individual tokens may be separated by arbitrary amounts of whitespace. For example, these three file contents are all legal and equivalent:

    i spongebob
    f Patrick
    s
or

    i spongebob f Patrick s
or

    i spongebob f
            Patrick    
    
    
    s
